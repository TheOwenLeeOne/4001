/*
 * msg_proc.c: implementation of the remote procedure "printmessage"
 *
 * Source: ?Using rpcgen?, http://www.cisco.com/en/US/docs/ios/sw_upgrades/interlink/r2_0/rpc_pr/rprpcgen.html
 */

#include <stdio.h>
#include <string.h>
#include <rpc/rpc.h>	/* always needed */
#include "msg.h"	/* need this too: msg.h will be generated by rpcgen */

#define BUFFER_SIZE 1024






char *openFile(){

	char * buffer;
	long length;
	FILE *f;

	f = fopen("output.txt", "r");// opens output file 
	if (f)
	{
		fseek (f, 0, SEEK_END);
		length = ftell (f);
		fseek (f, 0, SEEK_SET);
		buffer = malloc (length);
		if (buffer)
		{
			fread (buffer, 1, length, f);
		}
		fclose (f);	
	}
	if(buffer){
		return buffer;
	}
	else{
		printf("Error reading file");
		return(NULL);
	}
}

int findWordInSentence(char text[], char query[]){
	if(strstr(text, query)!=NULL){
		return 1;
	}
	else{
		return 0;
	}
}

int findSentenceLocation(char *query){
	const char s[2] = ".";

	
	
	char *text = openFile();
	char *sentence;

	sentence = strtok(text, s);
	
	int i = 0;
	while(sentence != NULL){
		//printf("%s\n", sentence);
		
		if(findWordInSentence(sentence, query) == 1){
			return i;
			break;
		}
		i++;
		sentence = strtok(NULL, s);
	}

	return (-1);
}




/*
 * Remote verson of "printmessage"
 */

int *printmessage_1_svc(char **msg, struct svc_req *rqstp)
{
	static int result; /* must be static! */
	FILE *f;

	f = fopen("output.txt", "a");// opens output file 
	if (f == NULL) 
	{
		result = 0;
		return (&result);
	}

	fprintf(f, "%s\n", *msg);//writes message
	fclose(f);

	result = 1;
	return (&result);
}




char **search_1_svc(char **msg, struct svc_req *rqstp){
	
	const char s[2] = ".";

	char *word = *msg;	
	
	char *text = openFile();


	char **sentence;

	*sentence = strtok(text, s);
	

	while(sentence != NULL){
		printf("%s\n", sentence);
		
		if(findWordInSentence(*sentence, word) == 1){
			return sentence;
		}
		*sentence = strtok(NULL, s);
	}

	return (NULL);

}



int *count_1_svc(char **msg, struct svc_req *rqstp){
	char *substring;
	int occur = 0;
	printf("count was called \n");
	static int result; 
	FILE *f;
	
	char *text = openFile();
	//printf(*msg,"\n");
	//printf(text);
	substring = strstr(text, *msg);
	printf(substring);
	while (substring!=NULL){
		printf("here2 \n",substring);
		occur++;
		substring++;
		printf("here1 %d \n",occur);
		substring = strstr(substring, *msg);
	}
	
	//printf("%s ", occur);
	//printf("printed text \n");
	
	result = occur;
	return (&result);
}

int *remove_1_svc(char **msg, struct svc_req *rqstp){
	
	const char *delimiter_characters = ".";
    int counter = 0;
    
    
    int line = findSentenceLocation(*msg);
    
    if(line==-1)
    {
		printf("could not find word\n");
		
		
		return 0;
	}
    
    char *fileInString = openFile();
    
    
    printf("derp");
    
  
      
	  FILE *input_file = fopen( "output.txt", "r+");
      FILE *output_file = fopen( "new_output.txt","w+");
    
    char *buffer;//[ BUFFER_SIZE];
    buffer = openFile();
    char *last_token;

    if( fileInString == NULL ){

        //fprintf( stderr, "Unable to open file %s\n", filename );

    }else{

        // Read each line into the buffer
     //   while( fgets(buffer, BUFFER_SIZE, input_file) != NULL ){

            // Write the line to stdout
            //fputs( buffer, stdout );

            // Gets each token as a string and prints it
            
            
            last_token = strtok( buffer, delimiter_characters );
            
            counter=0;
            
            
            while( (last_token != NULL)||(0!=strcmp("\n",last_token)) ){
				
				if (counter!=line){
				fputs(last_token,output_file);
				fputs(".",output_file);
                printf( "%s\n", last_token );
			}
				counter++;
                last_token = strtok( NULL, delimiter_characters );
            }
            
            
            if(unlink("output.txt")==0)
            {
				printf("UNLINK OK!\n");
			}
			else
			{
				printf("UNLINK BAD!\n");
			}

            rename("new_output.txt", "output.txt");

     //   }

        if( ferror(input_file) ){
            perror( "The following error occurred" );
        }

        fclose( input_file );
        fclose(output_file);

    }

    return 0;

	
	
	
}
